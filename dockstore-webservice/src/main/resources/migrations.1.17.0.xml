<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<!--
  ~    Copyright 2025 OICR and UCSC
  ~
  ~    Licensed under the Apache License, Version 2.0 (the "License");
  ~    you may not use this file except in compliance with the License.
  ~    You may obtain a copy of the License at
  ~
  ~        http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~    Unless required by applicable law or agreed to in writing, software
  ~    distributed under the License is distributed on an "AS IS" BASIS,
  ~    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~    See the License for the specific language governing permissions and
  ~    limitations under the License.
  -->

<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.5.xsd"
                   context="1.17.0">
    <changeSet author="svonworl" id="addMetricsRobotProperty">
        <addColumn tableName="enduser">
            <column defaultValueBoolean="false" name="metricsrobot" type="bool">
                 <constraints nullable="false"/>
            </column>
        </addColumn>
    </changeSet>
    <changeSet author="svonworl" id="limitMetricsRobotPrivileges">
        <sql dbms="postgresql">
            CREATE OR REPLACE FUNCTION raise_metrics_robot_privileges_exception()
            RETURNS TRIGGER AS $$
            BEGIN
            RAISE EXCEPTION 'a metrics robot can have no other privileges and is a metrics robot forever';
            END
            $$ LANGUAGE plpgsql;

            CREATE TRIGGER update_metrics_robot_to_non_metrics_robot BEFORE UPDATE ON enduser FOR EACH ROW WHEN (OLD.metricsrobot AND NOT NEW.metricsrobot) EXECUTE FUNCTION raise_metrics_robot_privileges_exception();
            CREATE TRIGGER update_metrics_robot_to_add_privileges BEFORE UPDATE ON enduser FOR EACH ROW WHEN (NEW.metricsrobot AND (NEW.isadmin OR NEW.curator OR NEW.platformpartner IS NOT NULL)) EXECUTE FUNCTION raise_metrics_robot_privileges_exception();
        </sql>
    </changeSet>
    <changeSet author="svonworl" id="tweakMetricsRobotProperty">
        <sql dbms="postgresql">
            DROP TRIGGER update_metrics_robot_to_non_metrics_robot ON enduser;
            DROP TRIGGER update_metrics_robot_to_add_privileges ON enduser;
        </sql>
        <modifyDataType columnName="metricsrobot" tableName="enduser" newDataType="varchar(255)"/>
        <dropDefaultValue columnName="metricsrobot" tableName="enduser"/>
        <dropNotNullConstraint columnName="metricsrobot" tableName="enduser"/>
        <renameColumn oldColumnName="metricsrobot" newColumnName="metricsrobotpartner" tableName="enduser"/>
        <sql dbms="postgresql">
            UPDATE enduser SET metricsrobotpartner = CASE WHEN metricsrobotpartner = 'true' THEN 'TOIL' ELSE NULL END;
        </sql>
        <sql dbms="postgresql">
            CREATE TRIGGER update_metrics_robot_to_non_metrics_robot BEFORE UPDATE ON enduser FOR EACH ROW WHEN (OLD.metricsrobotpartner IS NOT NULL AND NEW.metricsrobotpartner IS NULL) EXECUTE FUNCTION raise_metrics_robot_privileges_exception();
            ALTER TABLE enduser ADD CONSTRAINT metrics_robot_cannot_have_other_privileges CHECK (NOT (metricsrobotpartner IS NOT NULL AND (isadmin OR curator OR platformpartner IS NOT NULL)));
        </sql>
    </changeSet>
    <changeSet author="ktran (generated)" id="onlyOneInitiatorDoiPerEntry">
        <addColumn tableName="entry_concept_doi">
            <column name="doiinitiator" type="varchar(255 BYTE)"/>
        </addColumn>
        <sql dbms="postgresql">
            WITH concept_doi_initiator AS (
              SELECT entry_concept_doi.doiid AS concept_doi_id, doi.initiator
              FROM doi
              INNER JOIN entry_concept_doi ON doi.id = entry_concept_doi.doiid
            )
            UPDATE entry_concept_doi
            SET doiinitiator = concept_doi_initiator.initiator
            FROM concept_doi_initiator
            WHERE concept_doi_id = doiid;
        </sql>
        <addNotNullConstraint tableName="entry_concept_doi" columnName="doiinitiator"/>
        <sql dbms="postgresql">
          ALTER TABLE entry_concept_doi DROP CONSTRAINT IF EXISTS fk_doiid_entry_concept_doi;
          ALTER TABLE entry_concept_doi DROP CONSTRAINT IF EXISTS entry_concept_doi_pkey;
        </sql>
        <addPrimaryKey columnNames="entryid, doiid, doiinitiator" constraintName="entry_concept_doi_pkey" tableName="entry_concept_doi"/>
        <addColumn tableName="version_metadata_doi">
            <column name="doiinitiator" type="varchar(255 BYTE)">
            </column>
        </addColumn>
        <sql dbms="postgresql">
            WITH version_doi_initiator AS (
                SELECT version_metadata_doi.doiid AS version_doi_id, doi.initiator
                FROM doi
                INNER JOIN version_metadata_doi ON doi.id = version_metadata_doi.doiid
            )
            UPDATE version_metadata_doi
            SET doiinitiator = version_doi_initiator.initiator
            FROM version_doi_initiator
            WHERE version_doi_id = doiid;
        </sql>
        <addNotNullConstraint tableName="version_metadata_doi" columnName="doiinitiator"/>
        <dropForeignKeyConstraint baseTableName="version_metadata_doi" constraintName="fk_doiid_version_metadata_doi"/>
        <dropPrimaryKey tableName="version_metadata_doi"/>
        <addPrimaryKey columnNames="versionmetadataid, doiid, doiinitiator" constraintName="version_metadata_doi_pkey" tableName="version_metadata_doi"/>
        <sql dbms="postgresql">
            CREATE TEMPORARY TABLE dois_to_delete AS
            WITH multiple_dockstore_concept_doi_entries as (
                SELECT entryid, doiinitiator, COUNT(doiid)
                FROM entry_concept_doi
                GROUP BY entryid, doiinitiator
                HAVING COUNT(doiid) > 1
            ),
            concept_dois_to_delete as (
                SELECT m.entryid, m.doiinitiator, e.doiid as doiidtodelete
                FROM multiple_dockstore_concept_doi_entries m
                INNER JOIN entry_concept_doi e
                ON m.entryid = e.entryid AND m.doiinitiator = e.doiinitiator
            ),
            version_dois_to_delete as (
                SELECT version_metadata_doi.versionmetadataid, version_metadata_doi.doiinitiator, version_metadata_doi.doiid as doiidtodelete
                FROM concept_dois_to_delete
                INNER JOIN workflowversion
                ON entryid = workflowversion.parentid
                INNER JOIN version_metadata_doi
                ON workflowversion.id = versionmetadataid
            )
            SELECT doiidtodelete
            FROM concept_dois_to_delete
            UNION ALL
            SELECT doiidtodelete
            FROM version_dois_to_delete;

            DELETE FROM version_metadata_doi WHERE doiid IN (SELECT * FROM dois_to_delete);
            DELETE FROM entry_concept_doi WHERE doiid IN (SELECT * FROM dois_to_delete);
            DELETE FROM doi WHERE id IN (SELECT * FROM dois_to_delete);
        </sql>
        <addUniqueConstraint columnNames="id, initiator" constraintName="unique_doi_id_initiatior" tableName="doi"/>
        <addUniqueConstraint columnNames="entryid, doiinitiator" constraintName="unique_entry_doiinitiator" tableName="entry_concept_doi"/>
        <addUniqueConstraint columnNames="versionmetadataid, doiinitiator" constraintName="unique_version_doiinitiator" tableName="version_metadata_doi"/>
    </changeSet>
</databaseChangeLog>
