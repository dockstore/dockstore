package cwl;
/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
@SuppressWarnings("all")
/** Represents a file (or group of files if `secondaryFiles` is specified) that
must be accessible by tools using standard POSIX file system call API such as
open(2) and read(2).
 */
@org.apache.avro.specific.AvroGenerated
public class File extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"File\",\"doc\":\"Represents a file (or group of files if `secondaryFiles` is specified) that\\nmust be accessible by tools using standard POSIX file system call API such as\\nopen(2) and read(2).\\n\",\"fields\":[{\"name\":\"class\",\"type\":{\"type\":\"enum\",\"name\":\"File_class\",\"symbols\":[\"File\"]},\"doc\":\"Must be `File` to indicate this object describes a file.\",\"jsonldPredicate\":{\"_type\":\"@vocab\",\"_id\":\"@type\"}},{\"name\":\"path\",\"type\":\"string\",\"doc\":\"The path to the file.\",\"jsonldPredicate\":{\"_type\":\"@id\"}},{\"name\":\"checksum\",\"type\":[\"null\",\"string\"],\"doc\":\"Optional hash code for validating file integrity.  Currently must be in the form\\n\\\"sha1$ + hexidecimal string\\\" using the SHA-1 algorithm.\\n\"},{\"name\":\"size\",\"type\":[\"null\",\"long\"],\"doc\":\"Optional file size.\"},{\"name\":\"secondaryFiles\",\"type\":[\"null\",{\"type\":\"array\",\"items\":\"File\"}],\"doc\":\"A list of additional files that are associated with the primary file\\nand must be transferred alongside the primary file.  Examples include\\nindexes of the primary file, or external references which must be\\nincluded when loading primary document.  A file object listed in\\n`secondaryFiles` may itself include `secondaryFiles` for which the same\\nrules apply.\\n\",\"jsonldPredicate\":\"cwl:secondaryFiles\"},{\"name\":\"format\",\"type\":[\"null\",\"string\"],\"doc\":\"The format of the file.  This must be a URI of a concept node that\\nrepresents the file format, preferrably defined within an ontology.\\nIf no ontology is available, file formats may be tested by exact match.\\n\\nReasoning about format compatability must be done by checking that an\\ninput file format is the same or `rdfs:subClassOf` the format required\\nby the input parameter.\\n\\nIf no ontologies are specified in `formatOntologies`, the runtime may\\nperform exact file format matches.\\n\\nFile format ontologies are provided in the \\\"@schema\\\" section of the\\nfile's \\\"@context\\\".\\n\",\"jsonldPredicate\":{\"_type\":\"@id\",\"_id\":\"https://w3id.org/cwl/cwl#format\",\"identity\":true}}],\"docParent\":\"https://w3id.org/cwl/cwl#CWLType\"}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** Must be `File` to indicate this object describes a file. */
  @Deprecated public File_class class$;
  /** The path to the file. */
  @Deprecated public java.lang.CharSequence path;
  /** Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexidecimal string" using the SHA-1 algorithm.
 */
  @Deprecated public java.lang.CharSequence checksum;
  /** Optional file size. */
  @Deprecated public java.lang.Long size;
  /** A list of additional files that are associated with the primary file
and must be transferred alongside the primary file.  Examples include
indexes of the primary file, or external references which must be
included when loading primary document.  A file object listed in
`secondaryFiles` may itself include `secondaryFiles` for which the same
rules apply.
 */
  @Deprecated public java.util.List<File> secondaryFiles;
  /** The format of the file.  This must be a URI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same or `rdfs:subClassOf` the format required
by the input parameter.

If no ontologies are specified in `formatOntologies`, the runtime may
perform exact file format matches.

File format ontologies are provided in the "@schema" section of the
file's "@context".
 */
  @Deprecated public java.lang.CharSequence format;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public File() {}

  /**
   * All-args constructor.
   */
  public File(File_class class$, java.lang.CharSequence path, java.lang.CharSequence checksum, java.lang.Long size, java.util.List<File> secondaryFiles, java.lang.CharSequence format) {
    this.class$ = class$;
    this.path = path;
    this.checksum = checksum;
    this.size = size;
    this.secondaryFiles = secondaryFiles;
    this.format = format;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return class$;
    case 1: return path;
    case 2: return checksum;
    case 3: return size;
    case 4: return secondaryFiles;
    case 5: return format;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: class$ = (File_class)value$; break;
    case 1: path = (java.lang.CharSequence)value$; break;
    case 2: checksum = (java.lang.CharSequence)value$; break;
    case 3: size = (java.lang.Long)value$; break;
    case 4: secondaryFiles = (java.util.List<File>)value$; break;
    case 5: format = (java.lang.CharSequence)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'class$' field.
   * Must be `File` to indicate this object describes a file.   */
  public File_class getClass$() {
    return class$;
  }

  /**
   * Sets the value of the 'class$' field.
   * Must be `File` to indicate this object describes a file.   * @param value the value to set.
   */
  public void setClass$(File_class value) {
    this.class$ = value;
  }

  /**
   * Gets the value of the 'path' field.
   * The path to the file.   */
  public java.lang.CharSequence getPath() {
    return path;
  }

  /**
   * Sets the value of the 'path' field.
   * The path to the file.   * @param value the value to set.
   */
  public void setPath(java.lang.CharSequence value) {
    this.path = value;
  }

  /**
   * Gets the value of the 'checksum' field.
   * Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexidecimal string" using the SHA-1 algorithm.
   */
  public java.lang.CharSequence getChecksum() {
    return checksum;
  }

  /**
   * Sets the value of the 'checksum' field.
   * Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexidecimal string" using the SHA-1 algorithm.
   * @param value the value to set.
   */
  public void setChecksum(java.lang.CharSequence value) {
    this.checksum = value;
  }

  /**
   * Gets the value of the 'size' field.
   * Optional file size.   */
  public java.lang.Long getSize() {
    return size;
  }

  /**
   * Sets the value of the 'size' field.
   * Optional file size.   * @param value the value to set.
   */
  public void setSize(java.lang.Long value) {
    this.size = value;
  }

  /**
   * Gets the value of the 'secondaryFiles' field.
   * A list of additional files that are associated with the primary file
and must be transferred alongside the primary file.  Examples include
indexes of the primary file, or external references which must be
included when loading primary document.  A file object listed in
`secondaryFiles` may itself include `secondaryFiles` for which the same
rules apply.
   */
  public java.util.List<File> getSecondaryFiles() {
    return secondaryFiles;
  }

  /**
   * Sets the value of the 'secondaryFiles' field.
   * A list of additional files that are associated with the primary file
and must be transferred alongside the primary file.  Examples include
indexes of the primary file, or external references which must be
included when loading primary document.  A file object listed in
`secondaryFiles` may itself include `secondaryFiles` for which the same
rules apply.
   * @param value the value to set.
   */
  public void setSecondaryFiles(java.util.List<File> value) {
    this.secondaryFiles = value;
  }

  /**
   * Gets the value of the 'format' field.
   * The format of the file.  This must be a URI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same or `rdfs:subClassOf` the format required
by the input parameter.

If no ontologies are specified in `formatOntologies`, the runtime may
perform exact file format matches.

File format ontologies are provided in the "@schema" section of the
file's "@context".
   */
  public java.lang.CharSequence getFormat() {
    return format;
  }

  /**
   * Sets the value of the 'format' field.
   * The format of the file.  This must be a URI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same or `rdfs:subClassOf` the format required
by the input parameter.

If no ontologies are specified in `formatOntologies`, the runtime may
perform exact file format matches.

File format ontologies are provided in the "@schema" section of the
file's "@context".
   * @param value the value to set.
   */
  public void setFormat(java.lang.CharSequence value) {
    this.format = value;
  }

  /** Creates a new File RecordBuilder */
  public static File.Builder newBuilder() {
    return new File.Builder();
  }
  
  /** Creates a new File RecordBuilder by copying an existing Builder */
  public static File.Builder newBuilder(File.Builder other) {
    return new File.Builder(other);
  }
  
  /** Creates a new File RecordBuilder by copying an existing File instance */
  public static File.Builder newBuilder(File other) {
    return new File.Builder(other);
  }
  
  /**
   * RecordBuilder for File instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<File>
    implements org.apache.avro.data.RecordBuilder<File> {

    private File_class class$;
    private java.lang.CharSequence path;
    private java.lang.CharSequence checksum;
    private java.lang.Long size;
    private java.util.List<File> secondaryFiles;
    private java.lang.CharSequence format;

    /** Creates a new Builder */
    private Builder() {
      super(File.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(File.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.class$)) {
        this.class$ = data().deepCopy(fields()[0].schema(), other.class$);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.path)) {
        this.path = data().deepCopy(fields()[1].schema(), other.path);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.checksum)) {
        this.checksum = data().deepCopy(fields()[2].schema(), other.checksum);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.size)) {
        this.size = data().deepCopy(fields()[3].schema(), other.size);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.secondaryFiles)) {
        this.secondaryFiles = data().deepCopy(fields()[4].schema(), other.secondaryFiles);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.format)) {
        this.format = data().deepCopy(fields()[5].schema(), other.format);
        fieldSetFlags()[5] = true;
      }
    }
    
    /** Creates a Builder by copying an existing File instance */
    private Builder(File other) {
            super(File.SCHEMA$);
      if (isValidValue(fields()[0], other.class$)) {
        this.class$ = data().deepCopy(fields()[0].schema(), other.class$);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.path)) {
        this.path = data().deepCopy(fields()[1].schema(), other.path);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.checksum)) {
        this.checksum = data().deepCopy(fields()[2].schema(), other.checksum);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.size)) {
        this.size = data().deepCopy(fields()[3].schema(), other.size);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.secondaryFiles)) {
        this.secondaryFiles = data().deepCopy(fields()[4].schema(), other.secondaryFiles);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.format)) {
        this.format = data().deepCopy(fields()[5].schema(), other.format);
        fieldSetFlags()[5] = true;
      }
    }

    /** Gets the value of the 'class$' field */
    public File_class getClass$() {
      return class$;
    }
    
    /** Sets the value of the 'class$' field */
    public File.Builder setClass$(File_class value) {
      validate(fields()[0], value);
      this.class$ = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'class$' field has been set */
    public boolean hasClass$() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'class$' field */
    public File.Builder clearClass$() {
      class$ = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'path' field */
    public java.lang.CharSequence getPath() {
      return path;
    }
    
    /** Sets the value of the 'path' field */
    public File.Builder setPath(java.lang.CharSequence value) {
      validate(fields()[1], value);
      this.path = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'path' field has been set */
    public boolean hasPath() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'path' field */
    public File.Builder clearPath() {
      path = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'checksum' field */
    public java.lang.CharSequence getChecksum() {
      return checksum;
    }
    
    /** Sets the value of the 'checksum' field */
    public File.Builder setChecksum(java.lang.CharSequence value) {
      validate(fields()[2], value);
      this.checksum = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'checksum' field has been set */
    public boolean hasChecksum() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'checksum' field */
    public File.Builder clearChecksum() {
      checksum = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'size' field */
    public java.lang.Long getSize() {
      return size;
    }
    
    /** Sets the value of the 'size' field */
    public File.Builder setSize(java.lang.Long value) {
      validate(fields()[3], value);
      this.size = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'size' field has been set */
    public boolean hasSize() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'size' field */
    public File.Builder clearSize() {
      size = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'secondaryFiles' field */
    public java.util.List<File> getSecondaryFiles() {
      return secondaryFiles;
    }
    
    /** Sets the value of the 'secondaryFiles' field */
    public File.Builder setSecondaryFiles(java.util.List<File> value) {
      validate(fields()[4], value);
      this.secondaryFiles = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'secondaryFiles' field has been set */
    public boolean hasSecondaryFiles() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'secondaryFiles' field */
    public File.Builder clearSecondaryFiles() {
      secondaryFiles = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /** Gets the value of the 'format' field */
    public java.lang.CharSequence getFormat() {
      return format;
    }
    
    /** Sets the value of the 'format' field */
    public File.Builder setFormat(java.lang.CharSequence value) {
      validate(fields()[5], value);
      this.format = value;
      fieldSetFlags()[5] = true;
      return this; 
    }
    
    /** Checks whether the 'format' field has been set */
    public boolean hasFormat() {
      return fieldSetFlags()[5];
    }
    
    /** Clears the value of the 'format' field */
    public File.Builder clearFormat() {
      format = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    @Override
    public File build() {
      try {
        File record = new File();
        record.class$ = fieldSetFlags()[0] ? this.class$ : (File_class) defaultValue(fields()[0]);
        record.path = fieldSetFlags()[1] ? this.path : (java.lang.CharSequence) defaultValue(fields()[1]);
        record.checksum = fieldSetFlags()[2] ? this.checksum : (java.lang.CharSequence) defaultValue(fields()[2]);
        record.size = fieldSetFlags()[3] ? this.size : (java.lang.Long) defaultValue(fields()[3]);
        record.secondaryFiles = fieldSetFlags()[4] ? this.secondaryFiles : (java.util.List<File>) defaultValue(fields()[4]);
        record.format = fieldSetFlags()[5] ? this.format : (java.lang.CharSequence) defaultValue(fields()[5]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
